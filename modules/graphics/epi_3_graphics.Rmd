---
title: "R Graphics for the Graphics PowerPoint"
date: "2022-09-18 <br> Updated: `r Sys.Date()`"
---

# ‚≠êÔ∏èOverview

We have a PowerPoint called epi_3_graphics.pptx that I try to keep updated with graphics that can be used in my epi methods slides (and eventually R4EDpi). This Rmd file is for creating the R-based graphics that are found in that PowerPoint. 


# üì¶Load packages

```{r echo=FALSE}
library(dplyr, warn.conflicts = FALSE)
library(tidyr)
library(ggplot2)
library(templates)

# Load color template
data("my_colors")
```

# Populations and samples graphics

This code was copied and modified from: /Users/bradcannell/Dropbox/02 Teaching/R4Epi Textbook/r4epi/chapters/10_part_intro_epi/_02_measures_of_occurrence.Rmd

There is also some population plot stuff in R Notes.

There is also some population plot stuff in measures of occurrence.

## helper functions

Adding some helper functions to help with population plots.

```{r echo=FALSE}
# Helper function for sampling No and Yes - Simplified
sample_ny <- function(n = 100, prob_y = 0.5) {
  sample(c("No", "Yes"), n, TRUE, c(1 - prob_y, prob_y))
}

# For testing
# sample_ny(prob_y = 0.1)
```


```{r echo=FALSE}
# Create a pop of size x with e prop exposed and o prop with outcome
make_pop <- function(n_total = 100, 
                     prob_exposed, 
                     prob_outcome_exposed,
                     prob_outcome_unexposed,
                     arrange = FALSE) {
  # Figure out the smallest integer that will be at least size
  # n_total when multiplied by 2. The idea is to figure out the dimensions
  # for the closest thing I can get to a square given n_total
  n_sqrt <- sqrt(n_total)
  n_sqrt_ceiling <- ceiling(n_sqrt)
  drop <- n_sqrt_ceiling^2 - n_total
  
  # Make coordinates for grid of points
  pop <- expand_grid(
    x = seq(n_sqrt_ceiling),
    y = seq(n_sqrt_ceiling)
  )
  
  # Drop of n_sqrt is uneven. Drop from bottom right corner.
  # High x, low y.
  pop <- pop %>% 
    arrange(desc(y)) %>% 
    slice(1:(n() - drop)) %>% 
    arrange(x, y)
  
  # I still want y to be base 1
  pop$y <- pop$y + (1 - min(pop$y))
  
  # Add exposed and unexposed
  # Helper function for sampling No and Yes - Simplified
  sample_ny <- function(n = 100, prob_y = 0.5) {
    sample(c("No", "Yes"), n, TRUE, c(1 - prob_y, prob_y))
  }
  
  # Add exposed
  pop$exposed <- sample_ny(n = n_total, prob_y = prob_exposed)
  
  # Add outcome
  pop$outcome <- NA_character_
  n_exp_y <- sum(pop$exposed == "Yes")
  n_exp_n <- sum(pop$exposed == "No")
  pop$outcome[pop$exposed == "Yes"] <- sample_ny(n_exp_y, prob_y = prob_outcome_exposed)
  pop$outcome[pop$exposed == "No"] <- sample_ny(n_exp_n, prob_y = prob_outcome_unexposed)
  
  # Add exposure-outcome group columns
  # To combine the legend, we need to have a single variable with exposure 
  # and outcome information.
  pop <- pop %>% 
    mutate(
      e_o = case_when(
        exposed == "Yes" & outcome == "Yes" ~ "a",
        exposed == "Yes" & outcome == "No" ~ "b",
        exposed == "No" & outcome == "Yes" ~ "c",
        exposed == "No" & outcome == "No" ~ "d"
      ),
      e_o_f = factor(
        e_o, c("a", "b", "c", "d"),
        c(
          "Exposed - Outcome", "Exposed - No Outcome", 
          "Not exposed - Outcome", "Not exposed - No outcome"
        )
      )
    )
  
  # Arrange 
  # Sometimes I want the exposed-unexposed to be haphazardly spread around the 
  # plot. Sometimes, I want the exposed next to the exposed and the unexposed 
  # next to the unexposed.
  if (arrange) {
    # Separate x and y from the rest of the data before arranging
    x_y <- select(pop, x, y)
    pop <- pop %>% 
      select(-x, -y) %>% 
      arrange(desc(exposed), desc(outcome))
    # Add x and y back
    pop <- bind_cols(x_y, pop)
  }
  
  # Return tibble
  pop
}

# For testing
# set.seed(123)
# make_pop(
#   n_total = 100,
#   prob_exposed = 0.5,
#   prob_outcome_exposed = 0.5,
#   prob_outcome_unexposed = 0.1,
#   arrange = FALSE
# )
```

```{r echo=FALSE}
# Pull orange and blue colors from templates package
u_orange <- filter(my_colors, description == "University Orange") %>% pull(hex)
u_blue <- filter(my_colors, description == "University Blue") %>% pull(hex)
```

```{r echo=FALSE}
# Create a plot helper function
plot_pop <- function(.data, p_size = 5) {
  
  # Store shape codes
  cir <- 16
  tri <- 17
  
  # Create plot
  p <- ggplot(.data, aes(x, y, color = e_o_f, shape = e_o_f)) + 
    geom_point(size = p_size) +
    scale_color_manual("Exposure-Outcome", values = c(u_orange, u_orange, u_blue, u_blue)) +
    scale_shape_manual("Exposure-Outcome", values = c(tri, cir, tri, cir)) +
    theme(
      panel.background = element_blank(),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )
  
  # Return plot object
  p
}

# For testing
# pop_plot(pop, 5)
```

## Title slide

Creating a population graphic for the PowerPoint title slides.

```{r echo=FALSE}
# Create a population
set.seed(123)
pop <- make_pop(
  n_total = 306,
  prob_exposed = 0.5,
  prob_outcome_exposed = 0.5,
  prob_outcome_unexposed = 0.1,
  arrange = FALSE
)
```

```{r echo=FALSE}
# Plot it
pop %>% 
  plot_pop(p_size = 7) +
  # For the title slide, I want to remove the legend
  theme(legend.position = "none")

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/title_slide.png", width = 7.29, height = 4.51)
# ggsave("/users/bradcannell/Desktop/title_slide.png", width = 6.5, height = 7.5)
```

## Population without exposure or outcome

For discussion of populations and samples.

```{r}
pop <- expand_grid(x = 1:15, y = 1:15)
```

```{r}
ggplot(pop, aes(x, y)) + 
  geom_point(size = 8, color = u_orange) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/title_slide.png", width = 7.29, height = 4.51)
# ggsave("/users/bradcannell/Desktop/population.png", width = 6.5, height = 7.5)
```


# Measures of occurence

## Counts

```{r echo=FALSE}
set.seed(123)
# Create a 10x10 group of people
pop <- expand_grid(x = 1:10, y = 1:10)
pop$outcome <- sample_ny()
ggplot(pop, aes(x, y)) + 
  geom_point(size = 10, aes(color = outcome)) +
  scale_color_manual("Event", values = c(u_blue, u_orange)) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/count_plot.png", width = 7.29, height = 4.51)
```

```{r echo=FALSE}
set.seed(123)
# Create a 10x10 group of people
pop <- expand_grid(x = 1:10, y = 1:10)
pop$outcome <- sample_ny()
# Align colors
pop %>% 
  arrange(desc(outcome)) %>% 
  # Renumber the grid
  mutate(
    x = rep(1:10, each = 10),
    y = rep(1:10, 10)
  ) %>% 
ggplot(aes(x, y)) + 
  geom_point(size = 10, aes(color = outcome)) +
  scale_color_manual("Event", values = c(u_blue, u_orange)) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/count_plot_arranged.png", width = 7.29, height = 4.51)
```

```{r echo=FALSE}
# Try adding numbers
set.seed(123)
# Create a 10x10 group of people
pop <- expand_grid(x = 1:10, y = 1:10)
pop$outcome <- sample_ny()
# Align colors
pop %>% 
  arrange(desc(outcome)) %>% 
  # Renumber the grid
  mutate(
    x = rep(1:10, each = 10),
    y = rep(1:10, 10)
  ) %>% 
  # Create id numbers. The group_by is to make them appear in the order
  # we would typically count them in on the plot.
  mutate(id = row_number()) %>% 
  group_by(x) %>%
  mutate(id = rev(id)) %>% 
  ungroup() %>% 
ggplot(aes(x, y)) + 
  geom_point(size = 10, aes(color = outcome)) +
  geom_text(aes(label = id), color = "white") +
  scale_color_manual("Event", values = c(u_blue, u_orange)) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/count_plot_arranged_numbered.png", width = 7.29, height = 4.51)
```

```{r}
# Try numbering the people in the plot
set.seed(123)

# Create a 10x10 group of people
pop <- expand_grid(x = 1:10, y = 1:10)
pop$outcome <- sample_ny() |> sort()
n_no <- filter(pop, outcome == "No") |> nrow()
n_yes <- filter(pop, outcome == "Yes") |> nrow()
count <- c(seq(1, n_no), seq(1, n_yes))

# Rearrange the count number so that it displays in the order we want.
pop <- pop |> 
  mutate(count = count) |> 
  group_by(x, outcome) |> 
  mutate(count = rev(count))

# Create the plot
ggplot(pop, aes(x, y)) + 
  geom_point(size = 10, aes(color = outcome)) +
  geom_text(aes(label = count), color = "white") +
  scale_color_manual("Event", values = c(u_blue, u_orange)) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/count_plot_arranged_numbered.png", width = 7.29, height = 4.51)
```

```{r eval=FALSE, echo=FALSE}
# For PowerPoint
table(pop$outcome)
```

## Plot person-time

Trying to recreate Figure 4-1 in Modern Epidemiology 4th edition.

I think I want to do this as a [stacked bar chart](https://r-graph-gallery.com/48-grouped-barplot-with-ggplot2). I also thought about trying to do this as a [grid](https://stackoverflow.com/questions/51771416/plotting-a-grid-and-filling-in-cells-according-to-conditions-in-r). 

```{r}
people <- 1:10
months <- -1:12
pt_df <- expand_grid(person = people, month = months)
rows_per_person <- length(months)

# Count from the beginning of each month.
# So, person 2 is pre-follow-up at the beginning of time 1 (month -01), at risk 
# at the beginning of time 2 (month 00), at risk at the beginning of time 3 
# (month 01), diseased at the beginning of time 4 (month 02), etc.
p01 <- rep("Diseased", rows_per_person)
p02 <- c(rep("Pre-follow-up", 1), rep("At Risk", 2), rep("Diseased", 3), rep("Deceased", 8))
p03 <- c(rep("Pre-follow-up", 1), rep("At Risk", 4), rep("Diseased", 9), rep("Deceased", 0))
p04 <- c(rep("Pre-follow-up", 1), rep("At Risk", 5), rep("Diseased", 8), rep("Deceased", 0))
p05 <- c(rep("Pre-follow-up", 1), rep("At Risk", 7), rep("Diseased", 6), rep("Deceased", 0))
p06 <- c(rep("Pre-follow-up", 1), rep("At Risk", 8), rep("Diseased", 3), rep("Deceased", 2))
p07 <- c(rep("Pre-follow-up", 1), rep("At Risk", 9), rep("Diseased", 0), rep("Deceased", 4))
p08 <- c(rep("Pre-follow-up", 1), rep("At Risk", 5), rep("Diseased", 0), rep("Deceased", 8))
p09 <- c(rep("Pre-follow-up", 1), rep("At Risk", 13), rep("Diseased", 0), rep("Deceased", 0))
p10 <- c(rep("Pre-follow-up", 1), rep("At Risk", 13), rep("Diseased", 0), rep("Deceased", 0))
status <- c(p01, p02, p03, p04, p05, p06, p07, p08, p09, p10)

pt_df$status <- status

pt_df <- pt_df |> 
  mutate(
    person_f = factor(person, labels = c(paste0(0, 1:9), "10")),
    status_f = factor(status, levels = c("Pre-follow-up", "At Risk", "Diseased", "Deceased"))
  )

# Make a reverse order version of person and status
# Status: For bar stacking order
# Person: For displaying person 1 at the top of the y-axis after coord_flip
pt_df <- pt_df |> 
  mutate(
    status_f_rev = forcats::fct_rev(status_f),
    person_f_rev = forcats::fct_rev(person_f)
  )

# For testing adding more levels that don't always fall in order.
p02_diff <- c(rep("Pre-follow-up", 1), rep("consored", 2), rep("At Risk", 0), rep("Diseased", 3), rep("Deceased", 8))
p010_diff <- c(rep("Pre-follow-up", 1), rep("At Risk", 13), rep("Diseased", 3), rep("censored", 8))
status_diff <- c(p01, p02_dff, p03, p04, p05, p06, p07, p08, p09, p10_diff)
pt_df$status <- status
```

When I tried to add immigration, emigration, and loss to follow-up to the plot, I ran into problems with the bars overlapping in such a way that the status is sometimes hidden. I'm creating a second data frame below that has loss to follow-up for testing.

```{r}
people <- 1:10
months <- -1:12
pt_df_loss <- expand_grid(person = people, month = months)
rows_per_person <- length(months)

# Count from the beginning of each month.
# So, person 2 is pre-follow-up at the beginning of time 1 (month -01), at risk 
# at the beginning of time 2 (month 00), at risk at the beginning of time 3 
# (month 01), diseased at the beginning of time 4 (month 02), etc.
p01 <- rep("Diseased", rows_per_person)
p02 <- c(rep("Pre-follow-up", 1), rep("At Risk", 2), rep("Diseased", 3), rep("Deceased", 8))
p03 <- c(rep("Pre-follow-up", 1), rep("At Risk", 4), rep("Diseased", 9), rep("Deceased", 0))
p04 <- c(rep("Pre-follow-up", 1), rep("At Risk", 5), rep("Diseased", 8), rep("Deceased", 0))
# Person 05 leaves the population in month 6
p05 <- c(rep("Pre-follow-up", 1), rep("At Risk", 7), rep("Diseased", 0), rep("Deceased", 0), rep("Censored", 6))
p06 <- c(rep("Pre-follow-up", 1), rep("At Risk", 8), rep("Diseased", 3), rep("Deceased", 2))
p07 <- c(rep("Pre-follow-up", 1), rep("At Risk", 9), rep("Diseased", 0), rep("Deceased", 4))
p08 <- c(rep("Pre-follow-up", 1), rep("At Risk", 5), rep("Diseased", 0), rep("Deceased", 8))
# Person 09 enters the population in month 6
p09 <- c(rep("Pre-follow-up", 1), rep("Censored", 6), rep("At Risk", 7), rep("Diseased", 0), rep("Deceased", 0))
p10 <- c(rep("Pre-follow-up", 1), rep("At Risk", 13), rep("Diseased", 0), rep("Deceased", 0))
status <- c(p01, p02, p03, p04, p05, p06, p07, p08, p09, p10)

pt_df_loss$status <- status

pt_df_loss <- pt_df_loss |> 
  mutate(
    person_f = factor(person, labels = c(paste0(0, 1:9), "10")),
    status_f = factor(status, levels = c("Pre-follow-up", "At Risk", "Diseased", "Deceased", "Censored"))
  )

# Make a reverse order version of person and status
# Status: For bar stacking order
# Person: For displaying person 1 at the top of the y-axis after coord_flip
pt_df_loss <- pt_df_loss |> 
  mutate(
    status_f_rev = forcats::fct_rev(status_f),
    person_f_rev = forcats::fct_rev(person_f)
  )
```


### Stacked bar

To see all the steps I tried to get this to work see: https://stackoverflow.com/questions/77060918/how-to-control-the-z-axis-depth-of-bars-in-ggplot

#### Without censored data

```{r}
# This part makes the bars stack in the correct order.
pt_df_arrange <- arrange(pt_df, status_f_rev)

# Plot it
ggplot(pt_df_arrange, aes(person_f_rev, month, fill = status_f)) +
  geom_col(width = 1, position = position_dodge(0), color = "black") +
  # Add a line marking the start of follow up
  geom_hline(yintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_hline(yintercept = 1:12, color = "#f9f9f9") +
  # Show all months on the axis
  scale_y_continuous("Month Follow-up", breaks = months) +
  # Change fill colors
  scale_fill_manual("Status", values = c("white", "orange", "red", "black")) +
  # Change x-axis label
  xlab("Person") +
  # Flip the axes
  coord_flip() +
  # Change other theme elements
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    )
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/person_time_plot.png", width = 7.29, height = 4.51)
```

#### With censored data

```{r}
# This part makes the bars stack in the correct order.
pt_df_loss_arrange <- arrange(pt_df_loss, status_f_rev)

# Plot it
ggplot(pt_df_loss_arrange, aes(person_f_rev, month, fill = status_f)) +
  geom_col(width = 1, position = position_dodge(0), color = "black") +
  # Add a line marking the start of follow up
  geom_hline(yintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_hline(yintercept = 1:12, color = "#f9f9f9") +
  # Show all months on the axis
  scale_y_continuous("Month Follow-up", breaks = months) +
  # Change fill colors
  scale_fill_manual("Status", values = c("white", "orange", "red", "black", "yellow")) +
  # Change x-axis label
  xlab("Person") +
  # Flip the axes
  coord_flip() +
  # Change other theme elements
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    )
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/person_time_plot.png", width = 7.29, height = 4.51)
```

The downsides to `geom_col()` are:

1. The thickness of the bar is dependent on the number of values each person has for status. For example, The bar for person 01 and person 10 are thicker.
2. The bars will only overlay as desired when people experience the different statuses in the exact same order. When they don't, as with censored, the status isn't always visible. For example, we can't see the censored status in the first 6 months for person 09.

### Tile plot

Instead of sliding bars on top of each other, I could also use `geom_tile()` or `geom_raster()`. 
- `geom_raster`() is faster and the bars are easier to align.
- With `geom_tile()`, I can outline the bars.

I need to figure out how to outline the tiles: https://stackoverflow.com/questions/56380132/is-there-a-way-to-create-borders-around-rectangles-in-ggplot2-with-geom-raster

#### Without censored data

```{r}
ggplot(pt_df, aes(month, "p", fill = status_f)) + 
  geom_raster(hjust = 1) +
  # Create a bar marking the start of follow up
  geom_vline(xintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_vline(xintercept = 1:12, color = "#f9f9f9") +
  # Show all months
  scale_x_continuous("Month Follow-up", breaks = months) +
  facet_wrap(vars(person_f), nrow = 10, strip.position = "left") +
  # Change fill colors
  scale_fill_manual("Status", values = c("gray", "orange", "red", "black")) +
  # Change x-axis label
  ylab("Person") +
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Remove the "p" from the x axis
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    ),
    # Rotate the facet label to the right
    strip.text.y.left = element_text(angle = 0)
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/person_time_plot.png", width = 7.29, height = 4.51)
```

#### With censored data

```{r}
ggplot(pt_df_loss, aes(month, "p", fill = status_f, color = "black")) + 
  geom_raster(hjust = 1) +
  # Create a bar marking the start of follow up
  geom_vline(xintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_vline(xintercept = 1:12, color = "#f9f9f9") +
  # Show all months
  scale_x_continuous("Month Follow-up", breaks = months) +
  facet_wrap(vars(person_f), nrow = 10, strip.position = "left") +
  # Change fill colors
  scale_fill_manual("Status", values = c("gray", "orange", "red", "black", "yellow")) +
  # Change x-axis label
  ylab("Person") +
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Remove the "p" from the x axis
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    )
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/person_time_plot.png", width = 7.29, height = 4.51)
```


# Measures of association

## Population vs a sample

```{r}
pop <- expand_grid(x = 1:15, y = 1:15)
```

```{r}
ggplot(pop, aes(x, y)) + 
  geom_point(size = 8, color = u_orange) +
  # Draw sample box
   geom_rect(
    xmin = 0.5, xmax = 5.6, ymin = 4.5, ymax = 15.6,
    alpha = 0, color = "#4e738a", size = 2
  ) +
  # No legend
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
ggsave("/users/bradcannell/Desktop/population_w_sample.png", width = 6.5, height = 7.5)
```


# Normal distribution plot

<!-- Helpful site: http://t-redactyl.io/blog/2016/03/creating-plots-in-r-using-ggplot2-part-9-function-plots.html -->

```{r echo=FALSE}
mean      <- 68
sd        <- 10.95
limits    <- c(mean - 4 * sd, mean + 4 * sd)
my_breaks <- purrr::map_dbl(seq(-4, 4, 1), ~ mean + . * sd)
peak      <- dnorm(mean, mean = mean, sd = sd)

shaded <- function(x, n_sds) {
  y <- dnorm(x, mean = mean, sd = sd)
  y[x < (mean - n_sds * sd) | x > (mean + n_sds * sd)] <- NA
  y
}

y_labels <- function(x) {
  out <- dnorm(x, mean = mean, sd = sd)
  out
}

ggplot(tibble(x = c(limits[1], limits[2])), aes(x = x)) + 
  stat_function(fun = dnorm, args = list(mean = mean, sd = sd)) +
  geom_segment(aes(x = mean, y = 0, xend = mean, yend = peak), color = "red", linetype = "dashed") +
  scale_x_continuous("Heights", breaks = my_breaks) +
  # Add shaded area for 68%
  stat_function(fun = shaded, args = list(n_sds = 3), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(4, 6)], y = y_labels(my_breaks[c(4, 6)]), label = "1 SD \n 68%"), nudge_y = 0.007) +
  # Add shaded area for 95%
  stat_function(fun = shaded, args = list(n_sds = 2), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(3, 7)], y = y_labels(my_breaks[c(3, 7)]), label = "2 SD \n 95%"), nudge_y = 0.005) +
  # Add shaded area for 99%
  stat_function(fun = shaded, args = list(n_sds = 1), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(2, 8)], y = y_labels(my_breaks[c(2, 8)]), label = "3 SD \n 99%"), nudge_y = 0.003) +
  # Change theme
  theme_classic() +
  theme(
    axis.line.y = element_blank(), axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(), axis.title.y = element_blank(),
    axis.line.x = element_blank(), axis.text.x = element_blank(), 
    axis.ticks.x = element_blank(), axis.title.x = element_blank(),
  )

ggsave("/Users/bradcannell/Desktop/normal_curve.png")

rm(mean, sd, limits, my_breaks, peak, shaded, y_labels)
```

Normal distribution with mean 30 and standard error instead of standard deviation.

```{r echo=FALSE}
mean      <- 30
sd        <- 4
limits    <- c(mean - 4 * sd, mean + 4 * sd)
my_breaks <- purrr::map_dbl(seq(-4, 4, 1), ~ mean + . * sd)
peak      <- dnorm(mean, mean = mean, sd = sd)

shaded <- function(x, n_sds) {
  y <- dnorm(x, mean = mean, sd = sd)
  y[x < (mean - n_sds * sd) | x > (mean + n_sds * sd)] <- NA
  y
}

y_labels <- function(x) {
  out <- dnorm(x, mean = mean, sd = sd)
  out
}

ggplot(tibble(x = c(limits[1], limits[2])), aes(x = x)) + 
  stat_function(fun = dnorm, args = list(mean = mean, sd = sd)) +
  geom_segment(aes(x = mean, y = 0, xend = mean, yend = peak), color = "red", linetype = "dashed") +
  scale_x_continuous("BMI", breaks = my_breaks) +
  # Add shaded area for 68%
  stat_function(fun = shaded, args = list(n_sds = 3), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(4, 6)], y = y_labels(my_breaks[c(4, 6)]), label = "1 SE \n 68%"), nudge_y = 0.020) +
  # Add shaded area for 95%
  stat_function(fun = shaded, args = list(n_sds = 2), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(3, 7)], y = y_labels(my_breaks[c(3, 7)]), label = "2 SE \n 95%"), nudge_y = 0.015) +
  # Add shaded area for 99%
  stat_function(fun = shaded, args = list(n_sds = 1), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(2, 8)], y = y_labels(my_breaks[c(2, 8)]), label = "3 SE \n 99%"), nudge_y = 0.009) +
  # Change theme
  theme_classic() +
  theme(
    axis.line.y = element_blank(), axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(), axis.title.y = element_blank()
  )

ggsave("/Users/bradcannell/Desktop/normal_curve.png")

rm(mean, sd, limits, my_breaks, peak, shaded, y_labels)
```


# DAGS

## For confounding

### DAG - Ice cream and murder

```{r}
dag <- dagitty('dag {
  x [pos="0.000,0.000"]
  z [pos="1.000,1.000"]
  y [pos="2.000,0.000"]
  z -> x
  z -> y
}')

dag <- tidy_dagitty(dag) %>% 
  dag_label(labels = c(
    "x" = "ice cream", "y" = "murder", "z" = "temperature"
  ))
```

```{r}
ggdag(dag, use_labels = "label") + 
  theme_dag_blank()
```

```{r eval=FALSE, echo=FALSE}
ggsave("/Users/bradcannell/Desktop/dag_ice_cream_1.png", width = 3.5, height = 4)
```

```{r}
dag <- dagitty('dag {
  x [pos="0.000,0.000"]
  z [pos="1.000,1.000"]
  y [pos="2.000,0.000"]
  z -> x
  z -> y
  x -> y
}')

dag <- tidy_dagitty(dag) %>% 
  dag_label(labels = c(
    "x" = "ice cream", "y" = "murder", "z" = "temperature"
  ))
```

```{r}
set.seed(123)
ggdag(dag) + 
  geom_dag_label_repel(aes(label = label), nudge_x = .2, nudge_y = .5) +
  theme_dag_blank()
```

```{r}
ggdag(dag) +
  ggrepel::geom_label_repel(aes(label = label))
```


```{r eval=FALSE, echo=FALSE}
ggsave("/Users/bradcannell/Desktop/dag_ice_cream_2.png", width = 3.5, height = 4)
```

So far, I haven't been able to get the labels moved out of the way enough to see the arrows. I need to play around with this more when I have more time. 

 


# üóëClean up

```{r}
rm(list = ls())
```

```{r echo=FALSE}
sessionInfo()
```
