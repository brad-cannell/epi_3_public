---
title: "R Graphics for the Graphics PowerPoint"
date: "2022-09-18 <br> Updated: `r Sys.Date()`"
---

# ‚≠êÔ∏èOverview

We have a PowerPoint called epi_3_graphics.pptx that I try to keep updated with graphics that can be used in my epi methods slides (and eventually R4EDpi). This Rmd file is for creating the R-based graphics that are found in that PowerPoint. 


# üì¶Load packages

```{r echo=FALSE}
library(dplyr, warn.conflicts = FALSE)
library(tidyr)
library(ggplot2)
library(templates)

# Load color template
data("my_colors")
```

# Populations and samples graphics

This code was copied and modified from: /Users/bradcannell/Dropbox/02 Teaching/R4Epi Textbook/r4epi/chapters/10_part_intro_epi/_02_measures_of_occurrence.Rmd

There is also some population plot stuff in R Notes.

There is also some population plot stuff in measures of occurrence.

## helper functions

Adding some helper functions to help with population plots.

```{r echo=FALSE}
# Helper function for sampling No and Yes - Simplified
sample_ny <- function(n = 100, prob_y = 0.5) {
  sample(c("No", "Yes"), n, TRUE, c(1 - prob_y, prob_y))
}

# For testing
# sample_ny(prob_y = 0.1)
```


```{r echo=FALSE}
# Create a pop of size x with e prop exposed and o prop with outcome
make_pop <- function(n_total = 100, 
                     prob_exposed, 
                     prob_outcome_exposed,
                     prob_outcome_unexposed,
                     arrange = FALSE) {
  # Figure out the smallest integer that will be at least size
  # n_total when multiplied by 2. The idea is to figure out the dimensions
  # for the closest thing I can get to a square given n_total
  n_sqrt <- sqrt(n_total)
  n_sqrt_ceiling <- ceiling(n_sqrt)
  drop <- n_sqrt_ceiling^2 - n_total
  
  # Make coordinates for grid of points
  pop <- expand_grid(
    x = seq(n_sqrt_ceiling),
    y = seq(n_sqrt_ceiling)
  )
  
  # Drop of n_sqrt is uneven. Drop from bottom right corner.
  # High x, low y.
  pop <- pop %>% 
    arrange(desc(y)) %>% 
    slice(1:(n() - drop)) %>% 
    arrange(x, y)
  
  # I still want y to be base 1
  pop$y <- pop$y + (1 - min(pop$y))
  
  # Add exposed and unexposed
  # Helper function for sampling No and Yes - Simplified
  sample_ny <- function(n = 100, prob_y = 0.5) {
    sample(c("No", "Yes"), n, TRUE, c(1 - prob_y, prob_y))
  }
  
  # Add exposed
  pop$exposed <- sample_ny(n = n_total, prob_y = prob_exposed)
  
  # Add outcome
  pop$outcome <- NA_character_
  n_exp_y <- sum(pop$exposed == "Yes")
  n_exp_n <- sum(pop$exposed == "No")
  pop$outcome[pop$exposed == "Yes"] <- sample_ny(n_exp_y, prob_y = prob_outcome_exposed)
  pop$outcome[pop$exposed == "No"] <- sample_ny(n_exp_n, prob_y = prob_outcome_unexposed)
  
  # Add exposure-outcome group columns
  # To combine the legend, we need to have a single variable with exposure 
  # and outcome information.
  pop <- pop %>% 
    mutate(
      e_o = case_when(
        exposed == "Yes" & outcome == "Yes" ~ "a",
        exposed == "Yes" & outcome == "No" ~ "b",
        exposed == "No" & outcome == "Yes" ~ "c",
        exposed == "No" & outcome == "No" ~ "d"
      ),
      e_o_f = factor(
        e_o, c("a", "b", "c", "d"),
        c(
          "Exposed - Outcome", "Exposed - No Outcome", 
          "Not exposed - Outcome", "Not exposed - No outcome"
        )
      )
    )
  
  # Arrange 
  # Sometimes I want the exposed-unexposed to be haphazardly spread around the 
  # plot. Sometimes, I want the exposed next to the exposed and the unexposed 
  # next to the unexposed.
  if (arrange) {
    # Separate x and y from the rest of the data before arranging
    x_y <- select(pop, x, y)
    pop <- pop %>% 
      select(-x, -y) %>% 
      arrange(desc(exposed), desc(outcome))
    # Add x and y back
    pop <- bind_cols(x_y, pop)
  }
  
  # Return tibble
  pop
}

# For testing
# set.seed(123)
# make_pop(
#   n_total = 100,
#   prob_exposed = 0.5,
#   prob_outcome_exposed = 0.5,
#   prob_outcome_unexposed = 0.1,
#   arrange = FALSE
# )
```

```{r echo=FALSE}
# Pull orange and blue colors from templates package
u_orange <- filter(my_colors, description == "University Orange") %>% pull(hex)
u_blue <- filter(my_colors, description == "University Blue") %>% pull(hex)
```

```{r echo=FALSE}
# Create a plot helper function
plot_pop <- function(.data, p_size = 5) {
  
  # Store shape codes
  cir <- 16
  tri <- 17
  
  # Create plot
  p <- ggplot(.data, aes(x, y, color = e_o_f, shape = e_o_f)) + 
    geom_point(size = p_size) +
    scale_color_manual("Exposure-Outcome", values = c(u_orange, u_orange, u_blue, u_blue)) +
    scale_shape_manual("Exposure-Outcome", values = c(tri, cir, tri, cir)) +
    theme(
      panel.background = element_blank(),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )
  
  # Return plot object
  p
}

# For testing
# pop_plot(pop, 5)
```

## Title slide

Creating a population graphic for the PowerPoint title slides.

```{r echo=FALSE}
# Create a population
set.seed(123)
pop <- make_pop(
  n_total = 306,
  prob_exposed = 0.5,
  prob_outcome_exposed = 0.5,
  prob_outcome_unexposed = 0.1,
  arrange = FALSE
)
```

```{r echo=FALSE}
# Plot it
pop %>% 
  plot_pop(p_size = 7) +
  # For the title slide, I want to remove the legend
  theme(legend.position = "none")

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/title_slide.png", width = 7.29, height = 4.51)
# ggsave("/users/bradcannell/Desktop/title_slide.png", width = 6.5, height = 7.5)
```

## Population without exposure or outcome

For discussion of populations and samples.

```{r}
pop <- expand_grid(x = 1:15, y = 1:15)
```

```{r}
ggplot(pop, aes(x, y)) + 
  geom_point(size = 8, color = u_orange) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/title_slide.png", width = 7.29, height = 4.51)
# ggsave("/users/bradcannell/Desktop/population.png", width = 6.5, height = 7.5)
```


# Measures of occurence

## Counts

```{r echo=FALSE}
set.seed(123)
# Create a 10x10 group of people
pop <- expand_grid(x = 1:10, y = 1:10)
pop$outcome <- sample_ny()
ggplot(pop, aes(x, y)) + 
  geom_point(size = 10, aes(color = outcome)) +
  scale_color_manual("Event", values = c(u_blue, u_orange)) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/count_plot.png", width = 7.29, height = 4.51)
```

```{r echo=FALSE}
set.seed(123)
# Create a 10x10 group of people
pop <- expand_grid(x = 1:10, y = 1:10)
pop$outcome <- sample_ny()
# Align colors
pop %>% 
  arrange(desc(outcome)) %>% 
  # Renumber the grid
  mutate(
    x = rep(1:10, each = 10),
    y = rep(1:10, 10)
  ) %>% 
ggplot(aes(x, y)) + 
  geom_point(size = 10, aes(color = outcome)) +
  scale_color_manual("Event", values = c(u_blue, u_orange)) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/count_plot_arranged.png", width = 7.29, height = 4.51)
```

```{r echo=FALSE}
# Try adding numbers
set.seed(123)
# Create a 10x10 group of people
pop <- expand_grid(x = 1:10, y = 1:10)
pop$outcome <- sample_ny()
# Align colors
pop %>% 
  arrange(desc(outcome)) %>% 
  # Renumber the grid
  mutate(
    x = rep(1:10, each = 10),
    y = rep(1:10, 10)
  ) %>% 
  # Create id numbers. The group_by is to make them appear in the order
  # we would typically count them in on the plot.
  mutate(id = row_number()) %>% 
  group_by(x) %>%
  mutate(id = rev(id)) %>% 
  ungroup() %>% 
ggplot(aes(x, y)) + 
  geom_point(size = 10, aes(color = outcome)) +
  geom_text(aes(label = id), color = "white") +
  scale_color_manual("Event", values = c(u_blue, u_orange)) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/count_plot_arranged_numbered.png", width = 7.29, height = 4.51)
```

```{r}
# Try numbering the people in the plot
set.seed(123)

# Create a 10x10 group of people
pop <- expand_grid(x = 1:10, y = 1:10)
pop$outcome <- sample_ny() |> sort()
n_no <- filter(pop, outcome == "No") |> nrow()
n_yes <- filter(pop, outcome == "Yes") |> nrow()
count <- c(seq(1, n_no), seq(1, n_yes))

# Rearrange the count number so that it displays in the order we want.
pop <- pop |> 
  mutate(count = count) |> 
  group_by(x, outcome) |> 
  mutate(count = rev(count))

# Create the plot
ggplot(pop, aes(x, y)) + 
  geom_point(size = 10, aes(color = outcome)) +
  geom_text(aes(label = count), color = "white") +
  scale_color_manual("Event", values = c(u_blue, u_orange)) +
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/count_plot_arranged_numbered.png", width = 7.29, height = 4.51)
```

```{r eval=FALSE, echo=FALSE}
# For PowerPoint
table(pop$outcome)
```

## Plot person-time

Trying to recreate Figure 4-1 in Modern Epidemiology 4th edition.

I think I want to do this as a [stacked bar chart](https://r-graph-gallery.com/48-grouped-barplot-with-ggplot2). I also thought about trying to do this as a [grid](https://stackoverflow.com/questions/51771416/plotting-a-grid-and-filling-in-cells-according-to-conditions-in-r). 

```{r}
people <- 1:10
months <- -1:12
pt_df <- expand_grid(person = people, month = months)
rows_per_person <- length(months)

# Count from the beginning of each month.
# So, person 2 is pre-follow-up at the beginning of time 1 (month -01), at risk 
# at the beginning of time 2 (month 00), at risk at the beginning of time 3 
# (month 01), diseased at the beginning of time 4 (month 02), etc.
p01 <- rep("Diseased", rows_per_person)
p02 <- c(rep("Pre-follow-up", 1), rep("At Risk", 2), rep("Diseased", 3), rep("Deceased", 8))
p03 <- c(rep("Pre-follow-up", 1), rep("At Risk", 4), rep("Diseased", 9), rep("Deceased", 0))
p04 <- c(rep("Pre-follow-up", 1), rep("At Risk", 5), rep("Diseased", 8), rep("Deceased", 0))
p05 <- c(rep("Pre-follow-up", 1), rep("At Risk", 7), rep("Diseased", 6), rep("Deceased", 0))
p06 <- c(rep("Pre-follow-up", 1), rep("At Risk", 8), rep("Diseased", 3), rep("Deceased", 2))
p07 <- c(rep("Pre-follow-up", 1), rep("At Risk", 9), rep("Diseased", 0), rep("Deceased", 4))
p08 <- c(rep("Pre-follow-up", 1), rep("At Risk", 5), rep("Diseased", 0), rep("Deceased", 8))
p09 <- c(rep("Pre-follow-up", 1), rep("At Risk", 13), rep("Diseased", 0), rep("Deceased", 0))
p10 <- c(rep("Pre-follow-up", 1), rep("At Risk", 13), rep("Diseased", 0), rep("Deceased", 0))
status <- c(p01, p02, p03, p04, p05, p06, p07, p08, p09, p10)

pt_df$status <- status

pt_df <- pt_df |> 
  mutate(
    person_f = factor(person, labels = c(paste0(0, 1:9), "10")),
    status_f = factor(status, levels = c("Pre-follow-up", "At Risk", "Diseased", "Deceased"))
  )

# Make a reverse order version of person and status
# Status: For bar stacking order
# Person: For displaying person 1 at the top of the y-axis after coord_flip
pt_df <- pt_df |> 
  mutate(
    status_f_rev = forcats::fct_rev(status_f),
    person_f_rev = forcats::fct_rev(person_f)
  )
```

When I tried to add immigration, emigration, and loss to follow-up to the plot, I ran into problems with the bars overlapping in such a way that the status is sometimes hidden. I'm creating a second data frame below that has loss to follow-up for testing.

```{r}
people <- 1:10
months <- -1:12
pt_df_loss <- expand_grid(person = people, month = months)
rows_per_person <- length(months)

# Count from the beginning of each month.
# So, person 2 is pre-follow-up at the beginning of time 1 (month -01), at risk 
# at the beginning of time 2 (month 00), at risk at the beginning of time 3 
# (month 01), diseased at the beginning of time 4 (month 02), etc.
p01 <- rep("Diseased", rows_per_person)
p02 <- c(rep("Pre-follow-up", 1), rep("At Risk", 2), rep("Diseased", 3), rep("Deceased", 8))
p03 <- c(rep("Pre-follow-up", 1), rep("At Risk", 4), rep("Diseased", 9), rep("Deceased", 0))
p04 <- c(rep("Pre-follow-up", 1), rep("At Risk", 5), rep("Diseased", 8), rep("Deceased", 0))
# Person 05 leaves the population in month 6
p05 <- c(rep("Pre-follow-up", 1), rep("At Risk", 7), rep("Diseased", 0), rep("Deceased", 0), rep("Censored", 6))
p06 <- c(rep("Pre-follow-up", 1), rep("At Risk", 8), rep("Diseased", 3), rep("Deceased", 2))
p07 <- c(rep("Pre-follow-up", 1), rep("At Risk", 9), rep("Diseased", 0), rep("Deceased", 4))
p08 <- c(rep("Pre-follow-up", 1), rep("At Risk", 5), rep("Diseased", 0), rep("Deceased", 8))
# Person 09 enters the population in month 6
p09 <- c(rep("Pre-follow-up", 1), rep("Censored", 6), rep("At Risk", 7), rep("Diseased", 0), rep("Deceased", 0))
p10 <- c(rep("Pre-follow-up", 1), rep("At Risk", 13), rep("Diseased", 0), rep("Deceased", 0))
status <- c(p01, p02, p03, p04, p05, p06, p07, p08, p09, p10)

pt_df_loss$status <- status

pt_df_loss <- pt_df_loss |> 
  mutate(
    person_f = factor(person, labels = c(paste0(0, 1:9), "10")),
    status_f = factor(status, levels = c("Pre-follow-up", "At Risk", "Diseased", "Deceased", "Censored"))
  )

# Make a reverse order version of person and status
# Status: For bar stacking order
# Person: For displaying person 1 at the top of the y-axis after coord_flip
pt_df_loss <- pt_df_loss |> 
  mutate(
    status_f_rev = forcats::fct_rev(status_f),
    person_f_rev = forcats::fct_rev(person_f)
  )
```

### Function: Simulate data for person-time plots

```{r}
# For testing
# I want to be able to enter this directly into the .status argument of 
# sim_person_time_data below
test_status_list <- list(
  "Diseased",
  # "At Risk"
  c("At Risk" = 2, "Diseased" = 3, "Deceased" = 8)
)
```

```{r}
# Given the abbreviated list of lengths above, I want this function to return a 
# vector of number of reps for each status that I can use in the function below.
# This should only be used for named vectors of numbers. Not for a character 
# vector with one value (e.g., "Diseased" only).
list_to_reps <- function(.list, 
                         .statuses = c(
                           "Pre-follow-up", "At Risk", "Diseased", "Deceased", 
                           "Censored"
                         )) {
  v <- purrr::map_int(
    .statuses,
    function(x) {
      # If Pre-follow-up isn't specifically enumerated, then set it to 1
      if (x == "Pre-follow-up") {
        v <- if_else(x %in% names(.list), .list[x], 1)
      # If any other status isn't specifically enumerated, then set it to 0
      } else {
        v <- if_else(x %in% names(.list), .list[x],0)
      }
      v
    }
  )
  
  names(v) <- .statuses
  v
}

# Fort testing
# list_to_reps(test_status_list[[2]])["Pre-follow-up"]
```

```{r}
# Given the abbreviated list of lengths above, I want this function to return a 
# character vector of statuses that I can use in the sim_person_time_data 
# function below.
list_to_statuses <- function(.list, .rows) {
  statuses <- purrr::map(
    .list,
    function(x) {
      if (length(x) == 1) {
        v <- rep(x, .rows)
      } else {
        reps <- list_to_reps(x)
        v <- c(
          rep("Pre-follow-up", reps["Pre-follow-up"]),
          rep("At Risk", reps["At Risk"]),
          rep("Diseased", reps["Diseased"]),
          rep("Deceased", reps["Deceased"]),
          rep("Censored", reps["Censored"])
        )
      }
      # Return vector of statuses for each person
      v
    }
  )
  # Return vector of statuses for all people
  unlist(statuses)
}

# For testing
# list_to_statuses(test_status_list, .rows = 13)
```

```{r}
# Used for data checks in sim_person_time_data
get_status_names <- function(.list) {
  statuses <- purrr::map(
    .list,
    function(x) {
      if (length(x) == 1) {
        v <- x
      } else {
        v <- names(x)
      }
      v
    }
  )
  statuses <- unlist(statuses)
  statuses <- unique(statuses)
  statuses
}

# For testing
# get_status_names(test_status_list)
```


```{r}
sim_person_time_data <- function(.people, 
                                 .time,
                                 .status_levels = c("Pre-follow-up", "At Risk", "Diseased", "Deceased", "Censored"),
                                 .status_list) {
  # Checks
  # Check to make sure that the number of people being simulated matches the 
  # number of statuses provided.
  len_status <- length(.status_list)
  if (.people != len_status) {
    stop(".people = ", .people, ", but .status_list has a status for ", len_status, 
         " people. They should be the same.")
  }
  # Check to make sure there aren't any status levels provided to the .status_list
  # parameter that don't appear in the .status_levels parameter.
  unique_statuses <- get_status_names(.status_list)
  in_status_list_not_status_levels <- setdiff(unique_statuses, .status_levels)
  if (length(in_status_list_not_status_levels) > 0) {
    stop(
      in_status_list_not_status_levels, " is in .status_list, but not ",
      ".status_levels. Is there a typo?"
    )
  }
  
  # Set values
  people <- seq(.people)
  time <- -1:.time
  df <- tidyr::expand_grid(person = people, time = time)
  rows_per_person <- length(time)
  
  # Set stats for each person-period of time
  # Possible values are Pre-follow-up, At Risk, Diseased, Deceased, and Censored
  df$status <- list_to_statuses(.status_list, .rows = rows_per_person)
  
  # Create character versions of person number with leading zeros. They will be
  # used when we create factors below.
  if (.people < 9) {
    person_labs <- paste0(0, people)
  } else {
    person_labs <- c(paste0(0, 1:9), as.character(10:.people))
  }
  
  # Create factor versions of person and status
  df <- df |> 
    mutate(
      person_f = factor(person, labels = person_labs),
      status_f = factor(status, levels = .status_levels)
    )
  
  # Return data frame
  df
}

# For testing
# sim_person_time_data(
#   .people = 2,
#   .time = 12,
#   .status_list = list(
#     "Diseased",
#     c("At Risk" = 2, "Diseased" = 3, "Deceased" = 8)
#   )
# )
```


### Stacked bar

**Note**: Don't use this method. Just here for posterity.

To see all the steps I tried to get this to work see: https://stackoverflow.com/questions/77060918/how-to-control-the-z-axis-depth-of-bars-in-ggplot

#### Without censored data

```{r eval=FALSE}
# This part makes the bars stack in the correct order.
pt_df_arrange <- arrange(pt_df, status_f_rev)

# Plot it
ggplot(pt_df_arrange, aes(person_f_rev, month, fill = status_f)) +
  geom_col(width = 1, position = position_dodge(0), color = "black") +
  # Add a line marking the start of follow up
  geom_hline(yintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_hline(yintercept = 1:12, color = "#f9f9f9") +
  # Show all months on the axis
  scale_y_continuous("Month Follow-up", breaks = months) +
  # Change fill colors
  scale_fill_manual("Status", values = c("white", "orange", "red", "black")) +
  # Change x-axis label
  xlab("Person") +
  # Flip the axes
  coord_flip() +
  # Change other theme elements
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    )
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/person_time_plot.png", width = 7.29, height = 4.51)
```

#### With censored data

```{r eval=FALSE}
# This part makes the bars stack in the correct order.
pt_df_loss_arrange <- arrange(pt_df_loss, status_f_rev)

# Plot it
ggplot(pt_df_loss_arrange, aes(person_f_rev, month, fill = status_f)) +
  geom_col(width = 1, position = position_dodge(0), color = "black") +
  # Add a line marking the start of follow up
  geom_hline(yintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_hline(yintercept = 1:12, color = "#f9f9f9") +
  # Show all months on the axis
  scale_y_continuous("Month Follow-up", breaks = months) +
  # Change fill colors
  scale_fill_manual("Status", values = c("white", "orange", "red", "black", "yellow")) +
  # Change x-axis label
  xlab("Person") +
  # Flip the axes
  coord_flip() +
  # Change other theme elements
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    )
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/person_time_plot.png", width = 7.29, height = 4.51)
```

The downsides to `geom_col()` are:

1. The thickness of the bar is dependent on the number of values each person has for status. For example, The bar for person 01 and person 10 are thicker.
2. The bars will only overlay as desired when people experience the different statuses in the exact same order. When they don't, as with censored, the status isn't always visible. For example, we can't see the censored status in the first 6 months for person 09.

### Tile plot

**Note**: Don't use this method. Just here for posterity.

Instead of sliding bars on top of each other, I could also use `geom_tile()` or `geom_raster()`. 
- `geom_raster`() is faster and the bars are easier to align.
- With `geom_tile()`, I can outline the bars. This seems like less of a problem when I color pre-follow-up gray instead of white.

I need to figure out how to outline the tiles: https://stackoverflow.com/questions/56380132/is-there-a-way-to-create-borders-around-rectangles-in-ggplot2-with-geom-raster

#### Without censored data

```{r eval=FALSE}
ggplot(pt_df, aes(month, "p", fill = status_f)) + 
  geom_raster(hjust = 1) +
  # Create a bar marking the start of follow up
  geom_vline(xintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_vline(xintercept = 1:12, color = "#f9f9f9") +
  # Show all months
  scale_x_continuous("Month Follow-up", breaks = months) +
  facet_wrap(vars(person_f), nrow = 10, strip.position = "left") +
  # Change fill colors
  scale_fill_manual("Status", values = c("gray", "orange", "red", "black")) +
  # Change x-axis label
  ylab("Person") +
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Remove the "p" from the x axis
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    ),
    # Rotate the facet label to the right
    strip.text.y.left = element_text(angle = 0)
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/person_time_plot.png", width = 7.29, height = 4.51)
```

#### With censored data

```{r eval=FALSE}
ggplot(pt_df_loss, aes(month, "p", fill = status_f)) + 
  geom_raster(hjust = 1) +
  # Create a bar marking the start of follow up
  geom_vline(xintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_vline(xintercept = 1:12, color = "#f9f9f9") +
  # Show all months
  scale_x_continuous("Month Follow-up", breaks = months) +
  facet_wrap(vars(person_f), nrow = 10, strip.position = "left") +
  # Change fill colors
  scale_fill_manual("Status", values = c("gray", "orange", "red", "black", "yellow")) +
  # Change x-axis label
  ylab("Person") +
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Remove the "p" from the x axis
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    )
  )

# Print for PowerPoint
# ggsave("/users/bradcannell/Desktop/person_time_plot.png", width = 7.29, height = 4.51)
```

Using this method, we are counting past the end of follow-up. In other words, the last point on the x-axis should be 12 (in this data). We don't know what happens after their 12-month follow-up visit. Practically, it prevents us being able to calculate time at risk directly from the data.

Let's make a smaller toy data set 

```{r  eval=FALSE}
test_pop <- sim_person_time_data(
  .people = 2,
  .time = 4,
  .status_list = list(
    "Diseased",
    c("At Risk" = 5, "Diseased" = 0, "Deceased" = 0)
  )
)
```

```{r  eval=FALSE}
ggplot(test_pop, aes(time, "p", fill = status_f)) + 
  # By default, the tile is centered over the x-axis value.
  # we want it flush
  geom_raster(hjust = 1) +
  # Create a bar marking the start of follow up
  geom_vline(xintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_vline(xintercept = 1:4, color = "#f9f9f9") +
  # Show all months
  scale_x_continuous("Month Follow-up", breaks = 1:4) +
  facet_wrap(vars(person_f), nrow = 2, strip.position = "left") +
  # Change fill colors
  scale_fill_manual("Status", values = c("gray", "orange", "red", "black", "yellow")) +
  # Change x-axis label
  ylab("Person") +
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Remove the "p" from the x axis
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    )
  )
```

```{r  eval=FALSE}
ggplot(test_pop, aes(time, person_f, fill = status_f)) + 
  geom_tile(color = "black") +
  scale_x_continuous("Month Follow-up", breaks = -1:4)
```


Maybe it isn't a problem actually. Give this some thought. We do a baseline assessment (time 0). Do we do another one at the 12th month? Look at the figure. We get their status at baseline, etc. AT the fourth month, we know they are at risk. We don't know what happens at 4 months + one day. Having said that, do we care? That is outside the study period. What would happen if they had disease at the 12 month follow-up visit (so, sometime between month 11 and month 12)? Would we say that they developed disease during the 12 months of follow-up? Yes. I think so.

Having said that, we don't want to count the time between month 12 and month 13 as person-time at risk. I think that is the main issue here. They may be at risk, but they are at risk outside of our observation. We don't count it towards their person-time. 

We need to handle diseased and at risk differently.

### Geom_segment

Use this method!

```{r  eval=FALSE}
test_pop <- sim_person_time_data(
  .people = 2,
  .time = 4,
  .status_list = list(
    "Diseased",
    c("At Risk" = 5, "Diseased" = 0, "Deceased" = 0)
  )
)
```

How do we convert the other data to this format?

```{r}
test_pop |> 
  group_by(person_f, status_f) |> 
  mutate(
    x    = min(time),
    xend = max(time),
    y    = person,
    yend = person
  ) |> 
  ungroup() |> 
  # Keep distinct values only
  distinct(person, status, .keep_all = TRUE) |> 
  # Make the line ends touch
  group_by(person) |> 
  mutate(
    xend_adjusted = lead(x),
    xend_adjusted = if_else(is.na(xend_adjusted), xend, xend_adjusted)
  ) |> 
  ungroup() |> 
  ggplot() +
    geom_segment(aes(x = x, xend = xend_adjusted, y = 1, yend = 1, color = status_f), size = 3) +
    facet_wrap(vars(person_f), nrow = 4)
```

```{r}
pt_df_loss_segment <- pt_df_loss |> 
  group_by(person_f, status_f) |> 
  mutate(
    x    = min(month),
    xend = max(month),
    y    = person,
    yend = person
  ) |> 
  ungroup() |> 
  # Keep distinct values only
  distinct(person, status, .keep_all = TRUE) |> 
  # Make the line ends touch
  group_by(person) |> 
  mutate(
    xend_adjusted = lead(x),
    xend_adjusted = if_else(is.na(xend_adjusted), xend, xend_adjusted)
  ) |> 
  relocate(xend_adjusted, .after = xend) |> 
  ungroup()
```

```{r}
ggplot(pt_df_loss_segment) +
  geom_segment(aes(x = x, xend = xend_adjusted, y = 1, yend = 1, color = status_f), size = 5) +
  # Show all months
  scale_x_continuous("Month Follow-up", breaks = -1:12) +
  facet_wrap(vars(person_f), nrow = 10, strip.position = "left") +
  # Add a line marking the start of follow up
  geom_vline(xintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_vline(xintercept = 1:12, color = "#f9f9f9") +
  # Change fill colors
  scale_color_manual("Status", values = c("gray", "orange", "red", "black", "#4682B4")) +
  # Change y-axis label
  ylab("Person") +
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Remove the "p" from the x axis
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    ),
    # Rotate the facet label to the right
    strip.text.y.left = element_text(angle = 0)
  )
```

#### Count time at risk

Can I get an accurate count of time at risk? It should be 58.

```{r}
pt_df_loss_segment |> 
  filter(status == "At Risk") |> 
  mutate(time_at_risk = xend_adjusted - x) |> 
  summarise(time_at_risk = sum(time_at_risk))
```

So, this should work!!


# Person-time plot with exposure status

```{r}
pt_df_exposed <- pt_df |> 
  mutate(
    exposed   = if_else(person %% 2 == 0, 1, 0),
    exposed_f = factor(exposed, 0:1, c("No", "Yes"))
  )

pt_df_exposed_wide <- pt_df_exposed |> 
  group_by(person_f, status_f) |> 
  mutate(
    x    = min(month),
    xend = max(month),
    y    = person,
    yend = person
  ) |> 
  ungroup() |> 
  # Keep distinct values only
  distinct(person, status, .keep_all = TRUE) |> 
  # Make the line ends touch
  group_by(person) |> 
  mutate(
    xend_adjusted = lead(x),
    xend_adjusted = if_else(is.na(xend_adjusted), xend, xend_adjusted)
  ) |> 
  relocate(xend_adjusted, .after = xend) |> 
  ungroup()
```

```{r}
# To color the facet strip panels
stip_colors <- pt_df_exposed_wide |> 
  # Keep one row for each person
  distinct(person, .keep_all = TRUE) |> 
  # Add color to use by exposed status
  mutate(color = if_else(exposed == 1, "#817190", "#D9D9D9")) |> 
  pull(color)
strips <- ggh4x::strip_themed(background_y = ggh4x::elem_list_rect(fill = stip_colors))

ggplot(pt_df_exposed_wide, aes(group = exposed_f)) +
  geom_segment(aes(x = x, xend = xend_adjusted, y = 1, yend = 1, color = status_f), size = 5) +
  # Show all months
  scale_x_continuous("Month Follow-up", breaks = -1:12) +
  ggh4x::facet_wrap2(vars(person_f), nrow = 10, strip.position = "left", strip = strips) +
  # Add a line marking the start of follow up
  geom_vline(xintercept = 0, color = "blue") +
  # Add vertical lines to mark the start of each month
  geom_vline(xintercept = 1:12, color = "#f9f9f9") +
  # Change fill colors
  scale_color_manual("Status", values = c("gray", "orange", "red", "black", "#4682B4")) +
  # Change y-axis label
  ylab("Person") +
  theme(
    # Remove gray background
    panel.background = element_blank(),
    # Remove the "p" from the x axis
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Move legend
    legend.position = "bottom",
    # Change the color and style of the "months" axis 
    axis.line.x = element_line(
      color = "blue", arrow = grid::arrow(length = unit(0.1, "inches"), type = "closed")
    ),
    # Rotate the facet label to the right
    strip.text.y.left = element_text(angle = 0)
  )
```


# Random error

## Example: Error

There are valid philosophical debates to have regarding whether ‚Äútruth‚Äù is an absolute thing or a moving target, whether it is knowable or unknowable, and whether it exists at all. 

For the moment, however, we will put those philosophical discussions aside and say that our goal for any measure, be it descriptive, predictive, or explanatory, is the true underlying population value. 

For example, if the average age of our population of interest is 55, then any estimate of the average age that differs from 55 differs from the truth. 

To demonstrate, let's create a numeric vector of ages that will have a mean value, on average of 55.

```{r}
# Set the seed for the random number generator so that we can reproduce our results
set.seed(123)
# Create a numeric vector of ages
# It includes 10,000,000 values
# The mean of those values will be, on average, 55
# The standard deviation of those values will be, on average, 5
age <- rnorm(
  n    = 10000000,
  mean = 55,
  sd   = 5
)
```

```{r}
# Print the mean of the values stored in age to the screen
mean(age)
```

```{r}
## use of replicate() with parameters:
foo <- function(x = 1, y = 2) c(x, y)
# foo()
# foo(x = 3)
# does not work: bar <- function(n, ...) replicate(n, foo(...))
# replicate(5, foo(x = 3))
bar <- function(n, x) replicate(n, foo(x = x))
bar(5, x = 3)
```


```{r}
# Using this code to find random seeds that produce estimates that are far from the true value
n <- 1:2000
df <- data.frame(seed = vector("numeric", 2000), mean = vector("numeric", 2000))
for (i in n) {
  set.seed(i)
  df$seed[i] <- i
  df$mean[i] <- mean(sample(age, 10))
}
```

```{r}
# Using this code to find random seeds that produce estimates that are far from the true value
df |> 
  arrange(desc(mean))
```

Now, let's select 10 of the age values at random and save them to a new numeric vector.

```{r}
# Set the seed for the random number generator so that we can reproduce our results
set.seed(1318)
# Sample 10 ages at random
age_sample_01 <- sample(age, 10)
# Print the value stored in age_sample_01 to the screen
age_sample_01
```

üî¥ Come back and improve explanations

```{r}
# Print the mean of the values stored in age_sample_01 to the screen
mean_age_sample_01 <- mean(age_sample_01)
mean_age_sample_01
```

```{r}
# Set the seed for the random number generator so that we can reproduce our results
set.seed(435)
# Sample 10 ages at random
age_sample_02 <- sample(age, 10)
# Print the value stored in age_sample_01 to the screen
age_sample_02
```

```{r}
# Print the mean of the values stored in age_sample_01 to the screen
mean_age_sample_02 <- mean(age_sample_02)
mean_age_sample_02
```

üî¥ Create the graphic on slide 5?

üî¥ Create the graphic on slide 6?

## P-value curve

Vignette: https://cran.r-project.org/web/packages/pvaluefunctions/vignettes/pvaluefun.html

```{r}
mean_age_sample_01 - mean_age_sample_02
```

```{r}
t.test(age_sample_01, age_sample_02)
```

```{r}
res <- pvaluefunctions::conf_dist(
  estimate = c(-10.46871)
  , df = c(15.87)
  , tstat = c(-3.5052)
  , type = "ttest"
  , plot_type = "p_val"
  , n_values = 1e4L
  , conf_level = c(0.95, 0.90, 0.80)
  , null_values = c(0)
  , trans = "identity"
  , alternative = "two_sided"
  , log_yaxis = FALSE
  , cut_logyaxis = 0.05
  , xlab = "Mean difference (sample 01 - sample 02)"
  , together = FALSE
  , plot_p_limit = 1 - 0.999
  , plot_counternull = TRUE
  , x_scale = "line"
  , plot = TRUE
)
```

Ok, but I really want to learn how to do this by hand -- and using a measure from measures of occurrence. For example, using the population plot we created above, calculate the prevalence proportion, then calculate p-values and confidence intervals for the prevalence proportion. 

```{r}
# Create a vector containing the number of people with disease
n_condition <- 10
# Create a vector containing the number of people in the population of interest
n_population <- 15
# Calculate the prevalence proportion and assign it to an object called 
# prevalence_prop
prevalence_prop <- n_condition / n_population
# Print the value stored in prevalence_prop to the screen
prevalence_prop
```

What is the confidence interval for that prevalence proportion?





# Measures of association

## Population vs a sample

```{r}
pop <- expand_grid(x = 1:15, y = 1:15)
```

```{r}
ggplot(pop, aes(x, y)) + 
  geom_point(size = 8, color = u_orange) +
  # Draw sample box
   geom_rect(
    xmin = 0.5, xmax = 5.6, ymin = 4.5, ymax = 15.6,
    alpha = 0, color = "#4e738a", size = 2
  ) +
  # No legend
  theme(
    panel.background = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Print for PowerPoint
ggsave("/users/bradcannell/Desktop/population_w_sample.png", width = 6.5, height = 7.5)
```


# Normal distribution plot

<!-- Helpful site: http://t-redactyl.io/blog/2016/03/creating-plots-in-r-using-ggplot2-part-9-function-plots.html -->

```{r echo=FALSE}
mean      <- 68
sd        <- 10.95
limits    <- c(mean - 4 * sd, mean + 4 * sd)
my_breaks <- purrr::map_dbl(seq(-4, 4, 1), ~ mean + . * sd)
peak      <- dnorm(mean, mean = mean, sd = sd)

shaded <- function(x, n_sds) {
  y <- dnorm(x, mean = mean, sd = sd)
  y[x < (mean - n_sds * sd) | x > (mean + n_sds * sd)] <- NA
  y
}

y_labels <- function(x) {
  out <- dnorm(x, mean = mean, sd = sd)
  out
}

ggplot(tibble(x = c(limits[1], limits[2])), aes(x = x)) + 
  stat_function(fun = dnorm, args = list(mean = mean, sd = sd)) +
  geom_segment(aes(x = mean, y = 0, xend = mean, yend = peak), color = "red", linetype = "dashed") +
  scale_x_continuous("Heights", breaks = my_breaks) +
  # Add shaded area for 68%
  stat_function(fun = shaded, args = list(n_sds = 3), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(4, 6)], y = y_labels(my_breaks[c(4, 6)]), label = "1 SD \n 68%"), nudge_y = 0.007) +
  # Add shaded area for 95%
  stat_function(fun = shaded, args = list(n_sds = 2), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(3, 7)], y = y_labels(my_breaks[c(3, 7)]), label = "2 SD \n 95%"), nudge_y = 0.005) +
  # Add shaded area for 99%
  stat_function(fun = shaded, args = list(n_sds = 1), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(2, 8)], y = y_labels(my_breaks[c(2, 8)]), label = "3 SD \n 99%"), nudge_y = 0.003) +
  # Change theme
  theme_classic() +
  theme(
    axis.line.y = element_blank(), axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(), axis.title.y = element_blank(),
    axis.line.x = element_blank(), axis.text.x = element_blank(), 
    axis.ticks.x = element_blank(), axis.title.x = element_blank(),
  )

ggsave("/Users/bradcannell/Desktop/normal_curve.png")

rm(mean, sd, limits, my_breaks, peak, shaded, y_labels)
```

Normal distribution with mean 30 and standard error instead of standard deviation.

```{r echo=FALSE}
mean      <- 30
sd        <- 4
limits    <- c(mean - 4 * sd, mean + 4 * sd)
my_breaks <- purrr::map_dbl(seq(-4, 4, 1), ~ mean + . * sd)
peak      <- dnorm(mean, mean = mean, sd = sd)

shaded <- function(x, n_sds) {
  y <- dnorm(x, mean = mean, sd = sd)
  y[x < (mean - n_sds * sd) | x > (mean + n_sds * sd)] <- NA
  y
}

y_labels <- function(x) {
  out <- dnorm(x, mean = mean, sd = sd)
  out
}

ggplot(tibble(x = c(limits[1], limits[2])), aes(x = x)) + 
  stat_function(fun = dnorm, args = list(mean = mean, sd = sd)) +
  geom_segment(aes(x = mean, y = 0, xend = mean, yend = peak), color = "red", linetype = "dashed") +
  scale_x_continuous("BMI", breaks = my_breaks) +
  # Add shaded area for 68%
  stat_function(fun = shaded, args = list(n_sds = 3), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(4, 6)], y = y_labels(my_breaks[c(4, 6)]), label = "1 SE \n 68%"), nudge_y = 0.020) +
  # Add shaded area for 95%
  stat_function(fun = shaded, args = list(n_sds = 2), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(3, 7)], y = y_labels(my_breaks[c(3, 7)]), label = "2 SE \n 95%"), nudge_y = 0.015) +
  # Add shaded area for 99%
  stat_function(fun = shaded, args = list(n_sds = 1), geom = "area", fill = "#005493", alpha = 0.2) +
  geom_text(aes(x = my_breaks[c(2, 8)], y = y_labels(my_breaks[c(2, 8)]), label = "3 SE \n 99%"), nudge_y = 0.009) +
  # Change theme
  theme_classic() +
  theme(
    axis.line.y = element_blank(), axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(), axis.title.y = element_blank()
  )

ggsave("/Users/bradcannell/Desktop/normal_curve.png")

rm(mean, sd, limits, my_breaks, peak, shaded, y_labels)
```


# Tables with equations

I can't get equations to print properly in kable tables. This was the best I could do.

```{r echo=FALSE}
prob_def <- "If some process is repeated a large number of time, n, the relative frequency of occurrence of E, m/n, will be approximately equal to the probability of E."
conditional_prob_def <- "The probability that some event occurs given that we know that some other event has already occurred."
```

| Our Term                | Definition               | Equation                            |
|:------------------------|:------------------------:|:-----------------------------------:|
| Probability             | `r prob_def`             | $P(E) = \frac{m}{n}$                |
| Conditional probability | `r conditional_prob_def` | $P(Y|X) = \frac{P(Y \cap X)}{P(X)}$ |


# Contingency tables

I think the best way to create them my be with flextable

```{r}
crosstab <- tibble(
  `1` = c("", "Outcome +", "Outcome -"),
  `2` = c("Exposure +", "a", "b"),
  `3` = c("Exposure -", "c", "d")
)
```

Just adding the slide for now. Come back to this later.



# DAGS

## ggdag documentation

Following along with the ggdag documentation to make sure I understand how it works (https://cran.r-project.org/web/packages/ggdag/vignettes/intro-to-ggdag.html).

```{r}
library(dagitty)
library(ggdag)
library(ggplot2)
```

**Important**: Without either using set.seed or entering coordinates, the graph will look different every time.

```{r}
dag <- dagitty("dag{y <- z -> x}")
tidy_dagitty(dag)
```

```{r}
ggdag(dag)
```


`dagify()` creates dagitty DAGs using a more R-like syntax. It currently accepts formulas in the usual R style, e.g. y ~ x + z, which gets translated to ‚Å†y <- {x z}‚Å†, as well as using a double tilde (‚Å†~~‚Å†) to graph bidirected variables, e.g. x1 ~~ x2 is translated to ‚Å†x1 <-> x2‚Å†.

```{r}
dagified <- dagify(
  x ~ z,
  y ~ z,
  exposure = "x",
  outcome = "y"
)

tidy_dagitty(dagified)
```

```{r}
ggdag(dagified)
```

```{r}
tidy_dag <- tidy_dagitty(dagified)
str(tidy_dag)
```

```{r}
tidy_dag$data
```

```{r}
tidy_dag$dag
```

```{r}
ggdag(tidy_dag)
```
Most of the analytic functions in dagitty have extensions in ggdag and are named dag_\*() or node_\*(), depending on if they are working with specific nodes or the entire DAG. A simple example is `node_parents()`, which adds a column to the to the tidy_dagitty object about the parents of a given variable:

```{r}
node_parents(tidy_dag, "x")
```

Or working with the entire DAG to produce a tidy_dagitty that has all pathways between two variables:

```{r}
bigger_dag <- dagify(
  y ~ x + a + b,
  x ~ a + b,
  exposure = "x",
  outcome = "y"
)
```

```{r}
ggdag(bigger_dag)
```

```{r}
dag_paths(bigger_dag)
```

ggdag also supports piping of functions and includes the pipe internally (so you don‚Äôt need to load dplyr or magrittr). Basic dplyr verbs are also supported (and anything more complex can be done directly on the data object).

```{r}
# View open paths only
bigger_dag |> 
  dag_paths() |> 
  group_by(set) |> 
  filter(!is.na(path))
```

It looks like y to itself is always has a value of "open path" for the path column.

```{r}
# Find how many variables are in between x and y in each path
bigger_dag |> 
  dag_paths() |> 
  group_by(set) |> 
  filter(!is.na(path) & !is.na(name)) |> 
  summarize(n_vars_between = n() - 1L)
```

It looks like a "set" is a particular path. 
Set 1 = x -> y. There is only one variable on the path, x
Set 2 = a -> y and a -> x -> y. There are... hmm, this doesn't make sense either. I'm not sure how to make sense of the "3" above.

```{r}
ggdag_paths(bigger_dag)
```

This should be useful as a quiz question.

```{r}
ggdag_parents(bigger_dag, "x")
```

```{r}
#  quickly get the miniminally sufficient adjustment sets to adjust for when
#  analyzing the effect of x on y
ggdag_adjustment_set(bigger_dag) 
```

Examples from the `dagify()` help page.

```{r}
d <- dagify(y ~ x + z, x~ z)
d
```

```{r}
ggdag(d)
```

Add coordinate list

```{r}
coords <- list(
  x = c(A = 1, B = 2, D = 3, C = 3, F = 3,  E = 4, G = 5, H = 5, I = 5),
  y = c(A = 0, B = 0, D = 1, C = 0, F = -1, E = 0, G = 1, H = 0, I = -1)
)
```

```{r}
dag <- dagify(
  G ~~ H,
  G ~~ I,
  I ~~ G,
  H ~~ I,
  D ~ B,
  C ~ B,
  I ~ C + F,
  F ~ B,
  B ~ A,
  H ~ E,
  C ~ E + G,
  G ~ D, 
  coords = coords
)

dag
```

```{r}
ggdag(dag)
```

```{r}
dagitty::is.dagitty(dag)
```

Without either using set.seed or entering coordinates, the graph will look different every time.

```{r}
# Without either using set.seed or entering coordinates, the graph will look different every time.
set.seed(123)
dag2 <- dagify(
  y ~ x + z2 + w2 + w1,
  x ~ z1 + w1,
  z1 ~ w1 + v,
  z2 ~ w2 + v,
  w1 ~~ w2,
  exposure = "x",
  outcome = "y"
)
```

```{r}
ggdag(dag2)
```

## From: An Introduction to Directed Acyclic Graphs (https://cran.r-project.org/web/packages/ggdag/vignettes/intro-to-dags.html)

```{r}
#  set theme of all DAGs to `theme_dag()`
library(ggdag)
library(ggplot2)
theme_set(theme_dag())
```

A DAG displays assumptions about the relationship between variables (often called nodes in the context of graphs). The assumptions we make take the form of lines (or edges) going from one node to another. These edges are directed, which means to say that they have a single arrowhead indicating their effect. Here‚Äôs a simple DAG where we assume that x affects y:

```{r}
dagify(y ~ x) |> 
  ggdag()
```

```{r}
# This is my amendment because I like them to be on a straight line
dagify(
  y ~ x,
  coords = list(
    x = c(x = 1, y = 2),
    y = c(x = 0, y = 0)
  )
) |> 
  ggdag()
```

You also sometimes see edges that look bi-directed, like this:

```{r}
dagify(y ~~ x) %>%
  ggdag()
```

But this is actually shorthand for an unmeasured cause of the two variables (in other words, unmeasured confounding):

```{r}
#  canonicalize the DAG: Add the latent variable in to the graph
dagify(y ~~ x) %>%
  ggdag_canonical()
```

Let‚Äôs say we‚Äôre looking at the relationship between smoking and cardiac arrest. We might assume that smoking causes changes in cholesterol, which causes cardiac arrest:

**Note**: We can teach how to use labels and the exposure and outcome variables.

```{r}
set.seed(123)
smoking_ca_dag <- dagify(cardiacarrest ~ cholesterol,
  cholesterol ~ smoking + weight,
  smoking ~ unhealthy,
  weight ~ unhealthy,
  labels = c(
    "cardiacarrest" = "Cardiac\n Arrest",
    "smoking" = "Smoking",
    "cholesterol" = "Cholesterol",
    "unhealthy" = "Unhealthy\n Lifestyle",
    "weight" = "Weight"
  ),
  latent = "unhealthy",
  exposure = "smoking",
  outcome = "cardiacarrest"
)

ggdag(smoking_ca_dag, text = FALSE, use_labels = "label")
```

```{r}
set.seed(6)
ggdag_paths(smoking_ca_dag, text = FALSE, use_labels = "label", shadow = TRUE)
```

```{r}
ggdag_adjustment_set(smoking_ca_dag, text = FALSE, use_labels = "label", shadow = TRUE)
```

```{r}
fever_dag <- collider_triangle(
  x = "Influenza",
  y = "Chicken Pox",
  m = "Fever"
)

ggdag(fever_dag, text = FALSE, use_labels = "label")
```

```{r}
ggdag_dseparated(fever_dag, text = FALSE, use_labels = "label")
```

```{r}
ggdag_dseparated(fever_dag,
  controlling_for = "m",
  text = FALSE, use_labels = "label"
)
```

```{r}
dagify(fever ~ flu + pox,
  acetaminophen ~ fever,
  labels = c(
    "flu" = "Influenza",
    "pox" = "Chicken Pox",
    "fever" = "Fever",
    "acetaminophen" = "Acetaminophen"
  )
) %>%
  ggdag_dseparated(
    from = "flu", to = "pox", controlling_for = "acetaminophen",
    text = FALSE, use_labels = "label"
  )
```

```{r}
ggdag_dseparated(smoking_ca_dag,
  controlling_for = c("weight", "cholesterol"),
  text = FALSE, use_labels = "label", collider_lines = FALSE
)
```


## For confounding

### DAG - Ice cream and murder

```{r}
dag <- dagitty('dag {
  x [pos="0.000,0.000"]
  z [pos="1.000,1.000"]
  y [pos="2.000,0.000"]
  z -> x
  z -> y
}')

dag <- tidy_dagitty(dag) %>% 
  dag_label(labels = c(
    "x" = "ice cream", "y" = "murder", "z" = "temperature"
  ))
```

```{r}
ggdag(dag, use_labels = "label") + 
  theme_dag_blank()
```

```{r eval=FALSE, echo=FALSE}
ggsave("/Users/bradcannell/Desktop/dag_ice_cream_1.png", width = 3.5, height = 4)
```

```{r}
dag <- dagitty('dag {
  x [pos="0.000,0.000"]
  z [pos="1.000,1.000"]
  y [pos="2.000,0.000"]
  z -> x
  z -> y
  x -> y
}')

dag <- tidy_dagitty(dag) %>% 
  dag_label(labels = c(
    "x" = "ice cream", "y" = "murder", "z" = "temperature"
  ))
```

```{r}
set.seed(123)
ggdag(dag) + 
  geom_dag_label_repel(aes(label = label), nudge_x = .2, nudge_y = .5) +
  theme_dag_blank()
```

```{r}
ggdag(dag) +
  ggrepel::geom_label_repel(aes(label = label))
```


```{r eval=FALSE, echo=FALSE}
ggsave("/Users/bradcannell/Desktop/dag_ice_cream_2.png", width = 3.5, height = 4)
```

So far, I haven't been able to get the labels moved out of the way enough to see the arrows. I need to play around with this more when I have more time. 


## Shorten DAG distance

From: https://stackoverflow.com/questions/65420136/how-do-you-adjust-the-arrows-in-a-ggplot-of-a-ggdag

```{r}
#Create a tidy DAG
DAG <- dagify(y ~ x)
DAG <- tidy_dagitty(DAG)
DAG
```

```{r}
#Plot the DAG with default nodes
PLOT1 <- ggplot(ggplot2::aes(x = x, y = y, xend = xend, yend = yend), data = DAG) +
         geom_dag_point(colour = 'LightBlue') +
         geom_dag_edges() +
         geom_dag_text(colour = 'white') +
         theme_dag()
PLOT1
```

```{r}
#Plot the DAG with bigger nodes
PLOT2 <- ggplot(ggplot2::aes(x = x, y = y, xend = xend, yend = yend), data = DAG) +
         geom_dag_point(colour = 'LightBlue', size = 40) +
         geom_dag_edges() +
         geom_dag_text(colour = 'white') +
         theme_dag()
PLOT2
```

```{r}
shorten_dag_arrows <- function(tidy_dag, proportion){
# Update underlying ggdag object
tidy_dag$data <- dplyr::mutate(tidy_dag$data, 
                             xend = (1-proportion/2)*(xend - x) + x, 
                             yend = (1-proportion/2)*(yend - y) + y,
                             xstart = (1-proportion/2)*(x - xend) + xend,
                             ystart = (1-proportion/2)*(y-yend) + yend)
return(tidy_dag)
}
```

```{r}
DAG <- shorten_dag_arrows(DAG, 0.06)
DAG
```

```{r}
PLOT3 <- ggplot(ggplot2::aes(x = x, y = y, xend = xend, yend = yend), data = DAG) +
  geom_dag_point(colour = 'LightBlue', size = 40) +
  geom_dag_edges() +
  geom_dag_text(colour = 'white') +
  theme_dag()
PLOT3
```

## Make my custom simple dag

```{r dags-first-simple-dag, echo=FALSE, warning=FALSE}
# Create the DAG
simple_dag <- dagify(
  y ~ x,
  exposure = "x",
  outcome = "y",
  labels = c("x" = "Exposure", "y" = "Outcome"),
  coords = list(
    x = c(x = 1, y = 2),
    y = c(x = 0, y = 0)
  )
) 

# Make it a tidy_dagitty object to make it easier to modify some of the visual 
# characteristics of the DAG (e.g, add color).
simple_dag <- tidy_dagitty(simple_dag) |> 
  # Change x and xend so that the arrows are visible after increasing the 
  # size of the nodes below
  mutate(xstart = 1.03, xend = 1.97) |> 
  # Add custom colors to the nodes
  mutate(color = if_else(name == "x", "#ae6042", "#4e738a"))

# Basic ggdag  
# ggdag(simple_dag) +
#   theme_dag()

# For geom_dag_label_repel
set.seed(1)

# Create DAG with ggplot2 so that I can modify some of the visual 
# characteristics of the DAG (e.g, add color).
ggplot(simple_dag, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_point(size = 30, color = simple_dag$data$color) +
  geom_dag_edges(
    # Move the tail of the arrow away from the middle of the x node
    aes(x = xstart),
    # Make the arrowhead larger. Default is 5 pts.
    arrow_directed = grid::arrow(length = grid::unit(20, "pt"), type = "closed")) +
  geom_dag_text(size = 10) +
  geom_dag_label_repel(
    aes(label = label), 
    # Move the labels further from the center of the node
    box.padding = grid::unit(1, "lines"),
    # Erase the little line that "connects" the label box to the center of 
    # the node
    segment.size = 0
  ) +
  theme_dag()
```

# üóëClean up

```{r}
rm(list = ls())
```

```{r echo=FALSE}
sessionInfo()
```
